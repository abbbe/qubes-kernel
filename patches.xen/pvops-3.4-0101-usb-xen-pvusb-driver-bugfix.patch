diff -ur linux-3.4.18.orig/drivers/usb/host/xen-usbback/common.h linux-3.4.18/drivers/usb/host/xen-usbback/common.h
--- linux-3.4.18.orig/drivers/usb/host/xen-usbback/common.h	2012-11-19 20:54:07.498666857 +0100
+++ linux-3.4.18/drivers/usb/host/xen-usbback/common.h	2012-11-19 20:55:36.254666783 +0100
@@ -74,6 +74,9 @@
 
 #define XEN_USB_DEV_ADDR_SIZE 128
 
+#define CONN_RING_SIZE (PAGE_SIZE)
+#define URB_RING_SIZE (128 * PAGE_SIZE)
+
 struct xen_usbif {
 	domid_t				domid;
 	unsigned int			handle;
diff -ur linux-3.4.18.orig/drivers/usb/host/xen-usbback/usbback.c linux-3.4.18/drivers/usb/host/xen-usbback/usbback.c
--- linux-3.4.18.orig/drivers/usb/host/xen-usbback/usbback.c	2012-11-18 02:28:55.711999558 +0100
+++ linux-3.4.18/drivers/usb/host/xen-usbback/usbback.c	2012-11-18 21:50:31.380000062 +0100
@@ -134,8 +134,10 @@
 	was_empty = list_empty(&usbbk->pending_free);
 	list_add(&req->free_list, &usbbk->pending_free);
 	spin_unlock_irqrestore(&usbbk->pending_free_lock, flags);
-	if (was_empty)
+	if (was_empty) {
+		printk("WAIT: wake up usbbk->pending_free_wq=%p\n", &usbbk->pending_free_wq);
 		wake_up(&usbbk->pending_free_wq);
+	}
 }
 
 static inline void add_req_to_submitting_list(struct xen_usbdev *dev,
@@ -294,12 +296,14 @@
 
 static void usbif_notify_work(struct xen_usbif *usbif)
 {
+	printk("WAIT: wake up usbif->wq=%p\n", &usbif->wq);
 	usbif->waiting_reqs = 1;
 	wake_up(&usbif->wq);
 }
 
 irqreturn_t xen_usbif_be_int(int irq, void *dev_id)
 {
+	printk("IRQ: xen_usbif_be_int() called with irq=%d, dev_id=%p\n", irq, dev_id);
 	usbif_notify_work(dev_id);
 	return IRQ_HANDLED;
 }
@@ -457,17 +461,24 @@
 	res->start_frame = start_frame;
 	usbif->urb_ring.rsp_prod_pvt++;
 	barrier();
+	printk("RINGS: usbbk_do_response() pushes response %d into usbif->urb_ring(%p), rsp_prod_pvt=%d\n",
+		res->id, &usbif->urb_ring, usbif->urb_ring.rsp_prod_pvt);
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&usbif->urb_ring, notify);
 	spin_unlock_irqrestore(&usbif->urb_ring_lock, flags);
 
-	if (notify)
+	if (notify) {
+		printk("IRQ: usbbk_do_response(usbif=%p) calls notify_remote_via_irq(irq=%d)\n",
+			usbif, usbif->irq);
 		notify_remote_via_irq(usbif->irq);
+	}
 }
 
 static void usbbk_urb_complete(struct urb *urb)
 {
 	struct pending_req *pending_req = (struct pending_req *)urb->context;
 
+	printk("URB: usbbk_urb_complete(urb=%p)\n", urb);
+
 	if (usb_pipein(urb->pipe) && urb->status == 0 && urb->actual_length > 0)
 		copy_buff_to_pages(pending_req->buffer, pending_req, 0,
 					pending_req->nr_buffer_segs);
@@ -996,6 +1007,7 @@
 	barrier();
 
 	ret = usb_submit_urb(pending_req->urb, GFP_KERNEL);
+	printk("URB: usb_submit_urb(urb=%p) = %d\n", pending_req->urb, ret);
 	if (ret) {
 		pr_alert(DRV_PFX "failed submitting urb, error %d\n", ret);
 		ret = -ESHUTDOWN;
@@ -1027,25 +1039,37 @@
 	rp = urb_ring->sring->req_prod;
 	rmb();
 
+	printk("usbbk_start_submit_urb(usbif=%p) start\n", usbif);
+
 	while (rc != rp) {
 		if (RING_REQUEST_CONS_OVERFLOW(urb_ring, rc)) {
+			printk("RINGS: usbbk_start_submit_urb(): RING_REQUEST_CONS_OVERFLOW(usbif->urb_ring=%p)\n",
+				urb_ring);
 			pr_warn(DRV_PFX "RING_REQUEST_CONS_OVERFLOW\n");
 			break;
 		}
 
 		pending_req = alloc_req();
 		if (NULL == pending_req) {
+			printk("usbbk_start_submit_urb(%p): alloc_req() failed\n", usbif);
 			more_to_do = 1;
 			break;
 		}
 
 		req = RING_GET_REQUEST(urb_ring, rc);
+		printk("RINGS: usbbk_start_submit_urb() got request %d in usbif->urb_ring(%p), rc=%d\n",
+			req->id, urb_ring, rc);
+		// XXX isn't it too early to advance req_cons counter?
+        	printk("RINGS: usbbk_start_submit_urb() sets usbif->urb_ring(%p).req_cons := %d\n",
+			&usbif->urb_ring, (rc+1));
 		urb_ring->req_cons = ++rc;
 
 		dispatch_request_to_pending_reqs(usbif, req, pending_req);
 	}
 
 	RING_FINAL_CHECK_FOR_REQUESTS(&usbif->urb_ring, more_to_do);
+	printk("RINGS: usbbk_start_submit_urb() checked usbif->urb_ring(%p) for requests, more_to_do=%d\n",
+		&usbif->urb_ring, more_to_do);
 
 	cond_resched();
 
@@ -1063,22 +1087,37 @@
 
 	spin_lock_irqsave(&usbif->conn_ring_lock, flags);
 
+	// XXX is it possible there are no requests yet in the ring?
+
 	req = RING_GET_REQUEST(ring, ring->req_cons);
+	printk("RINGS: xen_usbif_hotplug_notify() got request %d from usbif->conn_ring(%p), req_cons=%d\n",
+		req->id, &usbif->conn_ring, ring->req_cons);
 	id = req->id;
+	printk("RINGS: xen_usbif_hotplug_notify() sets usbif->conn_ring(%p).req_cons=%d\n",
+		&usbif->conn_ring, (ring->req_cons + 1));
 	ring->req_cons++;
+	printk("RINGS: xen_usbif_hotplug_notify() sets usbif->conn_ring(%p).req_event=%d\n",
+		&usbif->conn_ring, (ring->req_cons + 1));
 	ring->sring->req_event = ring->req_cons + 1;
 
 	res = RING_GET_RESPONSE(ring, ring->rsp_prod_pvt);
+	printk("RINGS: xen_usbif_hotplug_notify() got response from usbif->conn_ring(%p), rc=%d\n",
+		ring, ring->rsp_prod_pvt);
 	res->id = id;
 	res->portnum = portnum;
 	res->speed = speed;
 	ring->rsp_prod_pvt++;
+	printk("RINGS: xen_usbif_hotplug_notify() pushes response %d into usbif->conn_ring(%p), rsp_prod_pvt=%d\n",
+		res->id, &usbif->conn_ring, ring->rsp_prod_pvt);
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(ring, notify);
 
 	spin_unlock_irqrestore(&usbif->conn_ring_lock, flags);
 
-	if (notify)
+	if (notify) {
+		printk("IRQ: xen_usbif_hotplug_notify(usbif=%p) calls notify_remote_via_irq(irq=%d)\n",
+			usbif, usbif->irq);
 		notify_remote_via_irq(usbif->irq);
+	}
 }
 
 int xen_usbif_schedule(void *arg)
@@ -1088,8 +1127,10 @@
 	usbif_get(usbif);
 
 	while (!kthread_should_stop()) {
+		printk("xen_usbif_schedule(%p): waiting for wq %p\n", arg, &usbif->wq);
 		wait_event_interruptible(usbif->wq,
 				usbif->waiting_reqs || kthread_should_stop());
+		printk("xen_usbif_schedule(%p): waiting for pending_free_wq %p\n", arg, &usbbk->pending_free_wq);
 		wait_event_interruptible(usbbk->pending_free_wq,
 		    !list_empty(&usbbk->pending_free) || kthread_should_stop());
 		usbif->waiting_reqs = 0;
diff -ur linux-3.4.18.orig/drivers/usb/host/xen-usbfront.c linux-3.4.18/drivers/usb/host/xen-usbfront.c
--- linux-3.4.18.orig/drivers/usb/host/xen-usbfront.c	2012-11-18 02:28:55.711999558 +0100
+++ linux-3.4.18/drivers/usb/host/xen-usbfront.c	2012-11-19 20:49:50.214666808 +0100
@@ -876,6 +876,8 @@
 		COUNT(info->stats.complete);
 	}
 	spin_unlock(&info->lock);
+	printk("URB: usb_hcd_giveback_urb(hdc=%p, urb=%p, status=%d)\n",
+		info_to_hcd(info), urb, (urbp->status <= 0 ? urbp->status : urb->status));
 	usb_hcd_giveback_urb(info_to_hcd(info), urb,
 				urbp->status <= 0 ? urbp->status : urb->status);
 	spin_lock(&info->lock);
@@ -912,9 +914,14 @@
 	info->shadow[id].urb = urb;
 	info->shadow[id].req = *req;
 
+	printk("RINGS: xenhcd_do_request() pushes request %d into info->urb_ring(%p), req_prod_pvt=%d\n",
+		req->id, &info->urb_ring, info->urb_ring.req_prod_pvt);
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->urb_ring, notify);
-	if (notify)
+	if (notify) {
+		printk("IRQ: xenhcd_do_request(info=%p) calls notify_remote_via_irq(irq=%d)\n",
+			info, info->irq);
 		notify_remote_via_irq(info->irq);
+	}
 
 	return ret;
 }
@@ -991,6 +998,7 @@
 	int ret = 0;
 
 	if (RING_FULL(&info->urb_ring)) {
+		printk("URB: xenhcd_submit_urb() info->urb_ring(%p) RING_FULL\n", &info->urb_ring);
 		list_add_tail(&urbp->list, &info->pending_submit_list);
 		COUNT(info->stats.ring_full);
 		timer_action(info, TIMER_RING_WATCHDOG);
@@ -998,6 +1006,7 @@
 	}
 
 	if (!list_empty(&info->pending_submit_list)) {
+		printk("URB: xenhcd_submit_urb() info->pending_submit_list empty\n");
 		list_add_tail(&urbp->list, &info->pending_submit_list);
 		timer_action(info, TIMER_SCAN_PENDING_URBS);
 		goto done;
@@ -1067,6 +1076,8 @@
 
 	for (i = info->urb_ring.rsp_cons; i != rp; i++) {
 		res = RING_GET_RESPONSE(&info->urb_ring, i);
+		printk("RINGS: got response %d in info->urb_ring(%p), rc=%d\n",
+			res->id, &info->urb_ring, i);
 		id = res->id;
 
 		if (likely(usbif_pipesubmit(info->shadow[id].req.pipe))) {
@@ -1084,17 +1095,25 @@
 
 		add_id_to_freelist(info, id);
 	}
+	printk("RINGS: xenhcd_urb_request_done() sets info->urb_ring(%p).rsp_cons := %d\n",
+		&info->urb_ring, i);
 	info->urb_ring.rsp_cons = i;
 
-	if (i != info->urb_ring.req_prod_pvt)
+	if (i != info->urb_ring.req_prod_pvt) {
 		RING_FINAL_CHECK_FOR_RESPONSES(&info->urb_ring, more_to_do);
-	else
+		printk("RINGS: xenhcd_urb_request_done() checked info->urb_ring(%p) for responses, more_to_do=%d\n",
+			&info->urb_ring, more_to_do);
+	} else {
+		printk("RINGS: xenhcd_urb_request_done() info->urb_ring(%p).sring->rsp_event := %d\n",
+			&info->urb_ring, i + 1);
 		info->urb_ring.sring->rsp_event = i + 1;
+	}
 
 	spin_unlock_irqrestore(&info->lock, flags);
 
 	cond_resched();
 
+	printk("xenhcd_urb_request_done(info=%p) end, more_to_do=%d\n", info, more_to_do);
 	return more_to_do;
 }
 
@@ -1118,9 +1137,12 @@
 
 	while (rc != rp) {
 		res = RING_GET_RESPONSE(&info->conn_ring, rc);
+		printk("RINGS: xenhcd_conn_notify() got response %d in info->conn_ring(%p), rc=%d\n",
+			res->id, &info->conn_ring, rc);
 		id = res->id;
 		portnum = res->portnum;
 		speed = res->speed;
+		printk("RINGS: xenhcd_conn_notify() sets info->conn_ring(%p).rsp_cons := %d\n", &info->conn_ring, (rc+1));
 		info->conn_ring.rsp_cons = ++rc;
 
 		rhport_connect(info, portnum, speed);
@@ -1133,16 +1155,29 @@
 					info->conn_ring.req_prod_pvt);
 		req->id = id;
 		info->conn_ring.req_prod_pvt++;
+		printk("RINGS: xenhcd_conn_notify() prepared request %d in info->conn_ring(%p), req_prod_pvt=%d\n",
+			req->id, &info->conn_ring, info->conn_ring.req_prod_pvt);
 	}
 
-	if (rc != info->conn_ring.req_prod_pvt)
+	if (rc != info->conn_ring.req_prod_pvt) {
 		RING_FINAL_CHECK_FOR_RESPONSES(&info->conn_ring, more_to_do);
-	else
+		printk("RINGS: xenhcd_conn_notify() checked for responses in info->conn_ring(%p), more_to_do=%d\n",
+			&info->conn_ring, more_to_do);
+	} else {
+		printk("RINGS: xenhcd_conn_notify() info->conn_ring(%p).sring->rsp_event := %d\n",
+			&info->conn_ring, (rc + 1));
 		info->conn_ring.sring->rsp_event = rc + 1;
+	}
 
+	printk("RINGS: xenhcd_conn_notify() pushes requests into info->conn_ring(%p), req_prod_pvt=%d\n",
+		&info->conn_ring, info->conn_ring.req_prod_pvt);
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->conn_ring, notify);
-	if (notify)
+
+	if (notify) {
+		printk("IRQ: xenhcd_conn_notify(info=%p) calls notify_remote_via_irq(irq=%d)\n",
+			info, info->irq);
 		notify_remote_via_irq(info->irq);
+	}
 
 	spin_unlock_irqrestore(&info->lock, flags);
 
@@ -1151,6 +1186,7 @@
 
 	cond_resched();
 
+	printk("xenhcd_conn_notify(info=%p): end, more_to_do=%d\n", info, more_to_do);
 	return more_to_do;
 }
 
@@ -1159,9 +1195,11 @@
 	struct usbfront_info *info = (struct usbfront_info *) arg;
 
 	while (!kthread_should_stop()) {
+		printk("WAIT: xenhcd_schedule(info=%p): waiting for info->wq %p\n", info, &info->wq);
 		wait_event_interruptible(info->wq,
 				info->waiting_resp || kthread_should_stop());
 		info->waiting_resp = 0;
+		printk("xenhcd_schedule(info=%p): woken up on info->wq %p\n", info, &info->wq);
 		smp_mb();
 
 		if (xenhcd_urb_request_done(info))
@@ -1177,11 +1215,13 @@
 static void xenhcd_notify_work(struct usbfront_info *info)
 {
 	info->waiting_resp = 1;
+	printk("xenhcd_notify_work(info=%p): wake up info->wq=%p\n", info, &info->wq);
 	wake_up(&info->wq);
 }
 
 irqreturn_t xenhcd_int(int irq, void *dev_id)
 {
+	printk("IRQ: xenhcd_int() called with irq=%d, dev_id=%p\n", irq, dev_id);
 	xenhcd_notify_work((struct usbfront_info *) dev_id);
 	return IRQ_HANDLED;
 }
@@ -1258,10 +1298,13 @@
 	unsigned long flags;
 	int ret = 0;
 
+	printk("URB: xenhcd_urb_enqueue(hcd=%p, urb=%p)\n", hcd, urb);
+
 	spin_lock_irqsave(&info->lock, flags);
 
 	urbp = alloc_urb_priv(urb);
 	if (!urbp) {
+		printk("URB: xenhcd_urb_enqueue(hcd=%p, urb=%p) alloc_urb_priv() FAILED!\n", hcd, urb);
 		ret = -ENOMEM;
 		goto done;
 	}
@@ -1405,7 +1448,7 @@
 		return -ENOMEM;
 	}
 	SHARED_RING_INIT(urb_sring);
-	FRONT_RING_INIT(&info->urb_ring, urb_sring, PAGE_SIZE);
+	FRONT_RING_INIT(&info->urb_ring, urb_sring, URB_RING_SIZE);
 
 	err = xenbus_grant_ring(dev, virt_to_mfn(info->urb_ring.sring));
 	if (err < 0) {
@@ -1422,7 +1465,7 @@
 		return -ENOMEM;
 	}
 	SHARED_RING_INIT(conn_sring);
-	FRONT_RING_INIT(&info->conn_ring, conn_sring, PAGE_SIZE);
+	FRONT_RING_INIT(&info->conn_ring, conn_sring, CONN_RING_SIZE);
 
 	err = xenbus_grant_ring(dev, virt_to_mfn(info->conn_ring.sring));
 	if (err < 0) {
@@ -1542,6 +1585,8 @@
 	}
 	info->conn_ring.req_prod_pvt = idx;
 
+	printk("RINGS: connect() pushes request %d into info->conn_ring(%p), req_prod_pvt=%d\n",
+		req->id, &info->conn_ring, info->conn_ring.req_prod_pvt);
 	RING_PUSH_REQUESTS_AND_CHECK_NOTIFY(&info->conn_ring, notify);
 	if (notify)
 		notify_remote_via_irq(info->irq);
